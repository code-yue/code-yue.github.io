[{"title":"继承-学习笔记","date":"2021-08-26T08:02:38.000Z","path":"2021/08/26/继承-学习笔记/","text":"继承——学习笔记。 继承：更专用的类（派生类）继承更一般的类（基类）的数据和行为。 return a==b; 如果a与b的值相等返回true，否则返回false。 派生类从基类继承所有成员函数和数据成员，但如果继承的行为不合适，可以改变其实现。 派生类对象上可以调用基类的成员函数，但是不能访问基类的数据成员。 对值的变化使用单个类，对行为的变化使用继承。 使用初始化器列表调用基类构造函数，来对数据成员进行初始化。 在派生类中重写成员函数时，如果在写此成员函数中需要调用基类的该函数，需使用基类::函数的方法。 派生类的对象可作为基类对象存储在基类数组中，但是对象数组会将派生类下降为基类对象，并将其数据进行切割，保留基类数据；如需保留派生类对象的所有数据，可使用指针数组进行储存，因为指针是对象的起始地址，每个派生类对象都是基类对象的特例，因此派生类对象的起始地址就是基类对象的起始地址，另外对于派生类重写的成员函数，想要实现根据指针所指向的对象的实际类型来确定访问哪一个成员函数，需要在基类同名的那个成员函数的声明中加入保留字virtual，在派生类中那个成员函数前加入保留字virtual是一个比较好的习惯。注：只有派生类指针可以赋值给基类指针，而基类指针不能赋值给派生类指针。 由类的结构层次中的不同的类访问对象，应使用指针，因为指向各种对象的指针都具有相同的大小——即内存地址的大小——而对象本身可能具有不同的大小。 虚函数：对于函数声明前加入保留字virtual。 当调用虚函数时，编译器都会在运行时确定特定调用中隐式参数的类型，然后调用该对象的适当函数。 虚函数使程序易于扩展，就是基于同一个基类的所有派生类可以储存在同一个基类的指针数组中，使得在对此数组进行循环访问时可以根据特定对象来访问特定的函数。 多态性：一个数组中收集两类问题或几类问题的混合，都基于同一个基类。 多态集合中的对象具有一些共性，但不一定属于同一个类型，继承用于表达这种共性，而虚函数可以实现行为的变化。 当函数具有多态参数时（即可以属于基类的参数，也可以属于派生类的参数），参数变量尽量使用指针或引用，否则会发生切割问题。 如果想要在派生类中重写虚函数，可以在函数声明的某尾加入override保留字，这样如果由于不小心写错了函数，使得函数由重写变成了重载（尤其时忘掉了const保留字），编译器会报错，另外如果不是虚函数的话。编译器也会报错。 当使用一组类时，我们要将他们组织到继承层次结构中，这使我们可以以统一的方式处理不同类的对象。 UML类图：是面向对象系统建模中最常用的图，其基本元素是类和接口。 逐步形成继承层次结构： 列出作为层次结构组成部分的类。 将各个类组织到继承层次结构当中（使用UML类图）。 确定公共职责。 确定在派生类中需要重写那些函数，并将需要重写的函数指定为虚函数。 定义每个派生类的公共接口。 确定数据成员。 实现构造函数和成员函数。 在空闲储存区上分配对象并处理它们。","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"继承","slug":"继承","permalink":"http://example.com/tags/%E7%BB%A7%E6%89%BF/"}]},{"title":"类-学习笔记","date":"2021-08-26T01:57:39.000Z","path":"2021/08/26/类-学习笔记/","text":"有关于类的一些需要注意的点，写下供以后进行复习。 类中数据成员和成员函数定义所需要的所有头文件都要在头文件中声明，并且如果引用了标准库中的头文件，就要包含伪指令 using namespace std；。 只读函数在声明和定义的时候都需要加const关键字。 类中this是隐式参数的指针，不是隐式参数。 类中的成员函数包括 构造函数，析构函数，只读函数，只写函数和助手函数。 封装：隐藏实现细节的同时提供公共接口的过程。 骆驼命名法：名字以大写字母开头，名字中的每一个单词也已大写字母开头。 类的结尾要有分号。 重载：同一个函数名用于多个函数。 将平行向量转化为对象的向量。","tags":[{"name":"类","slug":"类","permalink":"http://example.com/tags/%E7%B1%BB/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"Android_studio学习框架","date":"2021-08-23T07:47:23.000Z","path":"2021/08/23/Android-studio学习框架/","text":"​ 终于学了如何开发一个app，并能实现开发一个小app的能力，为了整理一下这些天学的内容以及方便以后复习，就做了一个学习内容的框架。 框架图","tags":[{"name":"Android studio框架","slug":"Android-studio框架","permalink":"http://example.com/tags/Android-studio%E6%A1%86%E6%9E%B6/"}]},{"title":"排序算法之计数排序","date":"2021-06-16T03:33:05.000Z","path":"2021/06/16/排序算法之计数排序/","text":"这里介绍第八种排序算法——计数排序 原理计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。不基于比较来对元素进行排序。 实现步骤 找出待排序的数组中最大num2和最小num1的元素。 统计数组中每个值为i的元素出现的次数，存入数组C的第i-num1项。 反向填充目标数组：对数组C中的每一个元素(从后向前遍历)从该元素值到1进行遍历，将该元素在数组中的位置+num1填充在原始数组中。其中有一个记录位置的变量，起始大小等于原始数组大小减一，每填充一个值就使其减一，直到原始数组填充完毕。 特性 最好、最坏、平均时间复杂度为：O(n+k) k是原始数组最大值减去最小值加一。 空间复杂度：O(k) 稳定性：稳定 动态演示 源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main()&#123; //待排序数组 int num[10]=&#123;1,5,9,3,4,7,6,8,0,2&#125;; //记录最小值 int num1=num[0]; //记录最大值 int num2= num[0]; for(int i=1;i&lt;sizeof num/4;i++) &#123; if(num[i]&lt;num1) &#123; num1=num[i]; &#125; if(num[i]&gt;num2) &#123; num2=num[i]; &#125; &#125; //对每一个出现的数进行计数 vector&lt;int&gt; num3(10); for(int i=0;i&lt;sizeof num/4;i++) &#123; num3[num[i]-num1]++; &#125; //记录排到的位置 int num4=sizeof num/4-1; //将数值从后向前填入数组中 for(int i=num2-num1;i&gt;=0;i--) &#123; for(int j=num3[i]-1;j&gt;=0;j--) &#123; num[num4]=i+num1; num4--; &#125; &#125; //打印数组 for(int i=0;i&lt;sizeof num/4;i++) &#123; cout &lt;&lt; num[i]&lt;&lt;&quot; &quot;; &#125; return 0;&#125;","tags":[{"name":"排序算法","slug":"排序算法","permalink":"http://example.com/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"}]},{"title":"排序算法之堆排序","date":"2021-06-15T15:44:23.000Z","path":"2021/06/15/排序算法之堆排序/","text":"前面介绍了6中排序算法，这里介绍第七种——堆排序。 堆和堆的性质 堆：堆是一种数据结构，一种叫做完全二叉树的数据结构。 堆的性质： 这里我们用到两种堆，其实也算是一种。 大顶堆：每个节点的值都大于或者等于它的左右子节点的值。 小顶堆：每个节点的值都小于或者等于它的左右子节点的值。 如下图所示，就是两种堆 如果我们把这种逻辑结构映射到数组中，就是下边这样 9 5 8 2 3 4 7 1 1 3 5 4 2 8 9 7 原理将数组中的最大值一个一个的交换到第一个位置，即num[0];然后在将其逐个放入数组的结尾，没放完一个，在程序中就使数组的大小减一，即堆的大小减一，直到数组中只剩下一个元素。 实现步骤 将带排序的序列构造成一个大顶堆，根据大顶堆的性质，当前堆的根节点（堆顶）就是序列中最大的元素。 将堆顶元素和最后一个元素交换，然后将剩下的节点重新构造成一个大顶堆。 重复步骤2，如此反复，从第一次构建大顶堆开始，每一次构建，我们都能获得一个序列的最大值，然后把它放到大顶堆的尾部。最后，就得到一个有序的序列了。 将最大值放入堆顶的方法： ​ 根据大顶堆的性质，每个节点的值都大于或者等于它的左右子节点的值。所以我们需要找到所有包含子节点的节点，也就是非叶子节点，然后调整他们的父子关系，非叶子节点遍历的顺序应该是从下往上，这比从上往下的顺序遍历次数少很多，因为，大顶堆的性质要求父节点的值要大于或者等于子节点的值，如果从上往下遍历，当某个节点即是父节点又是子节点并且它的子节点仍然有子节点的时候，因为子节点还没有遍历到，所以子节点不符合大顶堆性质，当子节点调整后，必然会影响其父节点需要二次调整。但是从下往上的方式不需要考虑父节点，因为当前节点调整完之后，当前节点必然比它的所有子节点都大，所以，只会影响到子节点二次调整。相比之下，从下往上的遍历方式比从上往下的方式少了父节点的二次调整。 几个关键值 树的层数，即堆的层数。 倒数第二层非叶子节点数。 剩下未排序列的数组大小。 特性 最好、最坏及平均时间复杂度：nlogn 以2为底 空间复杂度：O(1) 稳定性：不稳定 动态演示 源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;//声明堆排序函数void dui_sort(int num[],int num1);int main()&#123; //待排序数组 int num[10]= &#123;1,5,9,3,4,7,6,8,0,2&#125;; //数组大小 int size1 = sizeof num/4; //每进入一次函数就将一个最大的值放入数列末尾 for(int i=size1; i&gt;=2; i--) &#123; dui_sort(num,i); &#125; //打印数组 for(int i=0;i&lt;size1;i++) &#123; cout &lt;&lt; num[i]&lt;&lt;&quot; &quot;; &#125; return 0;&#125;void dui_sort(int num[],int num1)&#123; //记录树的层数，从第0层开始 int num2=0; int num3=num1; while(num3&gt;=2) &#123; num3=num3/2; num2++; &#125; //记录倒数第二层非叶子节点的个数 int num4=(num1-pow(2,num2))/2+1; //记录要排到的位置数 int num5=num1-1; for(int i=num2-1; i&gt;=0; i--) &#123; if(i==num2-1) &#123; for(int j=0; j&lt;num4; j++) &#123; int num6=pow(2,i)+j-1; if(num[num6]&lt;num[num6*2+1]) &#123; swap(num[num6],num[num6*2+1]); &#125; if(num[num6]&lt;num[num6*2+1+1]&amp;&amp;num6*2+1+1&lt;num1)//可能只有一个子叶所以需要判断是否越界 &#123; swap(num[num6],num[num6*2+1+1]); &#125; &#125; &#125; else &#123; for(int j=0; j&lt;pow(2,i); j++) &#123; int num6=pow(2,i)+j-1; if(num[num6]&lt;num[num6*2+1]) &#123; swap(num[num6],num[num6*2+1]); &#125; if(num[num6]&lt;num[num6*2+1+1]) &#123; swap(num[num6],num[num6*2+1+1]); &#125; &#125; &#125; &#125; swap(num[num5],num[0]);&#125;","tags":[{"name":"排序算法","slug":"排序算法","permalink":"http://example.com/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"}]},{"title":"排序算法之归并排序","date":"2021-06-13T12:40:59.000Z","path":"2021/06/13/排序算法之归并排序/","text":"排序算法的10大排序前面已经介绍了5个，下来介绍第6中排序算法——归并排序。 原理归并排序是创建在归并操作上的一种有效的排序算法。算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。归并排序思路简单，速度仅次于快速排序，为稳定排序算法，一般用于对总体无序，但是各子项相对有序的数列。 归并排序是用分治思想，分治模式在每一层递归上有三个步骤： 分解：将n个元素分成个含n/2个元素的子序列。 解决：用合并排序法对两个子序列递归的排序。 合并：合并两个已排序的子序列已得到排序结果。 实现步骤 进入归并排序函数merge-sort(int num[],int low,int high,int mid),其中low是数组起始值，high是数组最大值，mid是数组大小除以2。 设置递归开始条件，即下代码的if(low&lt;high)。 实行分而治之的思想，将数组一分为二，分别执行merge-sort函数，直到剩下一个数，不可再分。 对之前一份为二的数组进行化二为一进行排序合并。 排序合并方法： 定义一个向量。 将两个数组从小到大依次添加在向量后面。 将向量的值赋给原始数组的指定位置。 特性 时间复杂度：不管元素在什么情况下都要做这些步骤，所以花销的时间是不变的，所以该算法的最优时间复杂度和最差时间复杂度及平均时间复杂度都是一样的为：O( nlogn )，以2为底。 空间复杂度：O(n)。 稳定性：稳定 动态演示 源码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;//函数声明void merge_sort(int num[],int low,int high,int mid);int main()&#123; //待排序数组 int num[10]= &#123;2,3,9,8,7,5,4,6,1,0&#125;; //进入归并排序函数,其中4为数组大小除以2 merge_sort(num,0,9,4); //打印排序好的数组 for(int i=0; i&lt;10; i++) &#123; cout &lt;&lt; num[i]&lt;&lt; &quot; &quot;; &#125; return 0;&#125;//函数定义void merge_sort(int num[],int low,int high,int mid)&#123; //不满足if下的条件递归开始 if(low&lt;high) &#123; merge_sort(num,low,mid,(low+mid)/2); merge_sort(num,mid+1,high,(mid+1+high)/2); int num1 = low; int num2 = mid+1; //将数组中从low到high的数进行排序并存放在num4的向量之中 vector&lt;int&gt; num4; while(num1&lt;=mid&amp;&amp;num2&lt;=high) &#123; if(num[num1]&lt;=num[num2]) &#123; num4.push_back(num[num1]); num1++; &#125; else &#123; num4.push_back(num[num2]); num2++; &#125; &#125; if(num1&gt;mid) &#123; for(int i=num2; i&lt;=high; i++) &#123; num4.push_back(num[i]); &#125; &#125; else &#123; for(int i=num1; i&lt;=mid; i++) &#123; num4.push_back(num[i]); &#125; &#125; //将从low到high的数排序完存入数组中 for(int i=low; i&lt;=high; i++) &#123; num[i]=num4[i-low]; &#125; &#125;&#125;","tags":[{"name":"排序算法","slug":"排序算法","permalink":"http://example.com/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"}]},{"title":"排序算法之希尔排序","date":"2021-06-12T04:40:33.000Z","path":"2021/06/12/排序算法之希尔排序/","text":"前面我们介绍了插入排序：从后向前与每个相邻元素进行比较和交换，下面来介绍一下插入排序的改进版——希尔排序：实现不相邻的两个元素进行比较和交换，但实质上也是插入排序。 原理插入排序效率低下是因为其移动元素每次只能移动一位，当排序元素的规模较大时，需要将元素一位一位地从一端移动到另一端。而如果我们能够让元素一次性地移动到较远的位置上，这样无疑就可以避免多次一位一位地移动操作。希尔排序正是基于此原理来优化、提高插入排序的效率。通过指定步长step，将原数组分为step个互相独立子数组，然后通过插入排序对这些子数组分别进行排序(即分组排序)，这时我们称其为step有序数组。当step很大时，我们就可以将元素一次性移动到很远的位置上，为下一次较小的step有序创造便利；不断缩小步长step，重复上述过程建立step有序数组，达到局部有序的目的。当step最终为1做最后一次step有序时，就是我们平常所熟悉的插入排序了，由于该数组已经多次被较大的step进行分组排序了，此时只需要较少次数的元素移动就可以实现整个数组全局有序 实现步骤 定义一个增量gap大小就等于数组的大小。 进入一个while循环，条件是gap&gt;1,作用是当排序结束时跳出循环。 定义一个增量递减的倍数n，可以是小于数组大小的任意值，一般是2，3，4，并执行：gap=gap/n+1；注意这里如果n&gt;2的话，要在后加一，如：gap=gap/n+1，这是为了防止gap为0而不能进入最后一次插入排序;但是如果n=2的话，一定不能加一，否则可能会陷入无限循环。 通过增量将数组划分为若干个小数组。 对每一个小数组进行插入排序。 特性 时间复杂度：希尔排序的时间复杂度与其增量gap有关，平均时间复杂度为：O(n*(logn)^2),以2为底。 空间复杂度：O(1) 稳定性：不稳定 动态演示 源码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;using namespace std;int main()&#123; //待排序数组 int num[10]=&#123;0,1,5,9,2,4,8,3,6,7&#125;; //定义增量 int gap=10; //第一个循环:控制增量的，直到增量小于等于1时说明排序已经完成，跳出即可 while(gap&gt;1) &#123; gap=gap/3+1;//10是数组的长度，2是每次增量减小的倍数，+1是为了防止最后增量为0而无法进行插入排序，但当增量减小的倍数为2时不能加1 //第二个循环：通过增量将数组进行分组 for(int i=0;i&lt;gap&amp;&amp;i+gap&lt;10;i++) &#123; //第三和第四个循环：对每一组进行插入排序 for(int j=i+gap;j&lt;10;j+=gap) &#123; int temp = num[j]; int k; for(k=j-gap;k&gt;=i;k=k-gap) &#123; if(num[k]&gt;temp) &#123; num[k+gap]=num[k]; &#125; else &#123; break; &#125; &#125; num[k+gap]=temp; &#125; &#125; &#125; //打印数组 for(int i=0;i&lt;10;i++) &#123; cout &lt;&lt; num[i]&lt;&lt; &quot; &quot;; &#125; return 0;&#125;","tags":[{"name":"排序算法","slug":"排序算法","permalink":"http://example.com/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"}]},{"title":"排序算法之插入排序","date":"2021-06-11T14:46:27.000Z","path":"2021/06/11/排序算法之插入排序/","text":"前面介绍了冒泡排序，下面来介绍冒泡排序的姊妹排序——插入排序，虽然他们的原理不同，但是特性上面是完全相同的。 原理通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，直到找到相应的位置插入。 实现步骤 将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。 从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。） 特性 时间复杂度 最好情况：数组初始状态是正序的，此时的时间复杂度为O(n)。 最坏情况: 文件的初始状态是逆序的，此时的时间复杂度为O(n^2)。 综上：插入排序总的时间复杂度为 O(n^2)。 空间复杂度：无论什么情况都是O(1)。 稳定性: 稳定 动态演示 源码1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;using namespace std;int main()&#123; //待排序的数组 int num[10]=&#123;0,1,4,7,2,5,8,3,6,9&#125;; //逐个元素插入元素 for(int i=1;i&lt;10;i++) &#123; int temp = num[i];//存储要插入元素的值 int k=i-1;//记录插入元素的索引 while(k&gt;=0&amp;&amp;num[k]&gt;temp) &#123; num[k+1]=num[k]; k--; &#125; //插入元素 num[k+1]=temp; &#125; //打印数组 for(int i=0;i&lt;10;i++) &#123; cout &lt;&lt; num[i]&lt;&lt; &quot; &quot;; &#125; return 0;&#125;","tags":[{"name":"排序算法","slug":"排序算法","permalink":"http://example.com/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"}]},{"title":"排序算法之选择排序","date":"2021-06-11T13:48:53.000Z","path":"2021/06/11/排序算法之选择排序/","text":"选择排序是排序算法中最简单粗暴的一种，之前写过冒泡排序，而选择排序与冒泡排序有相似之处，但时间复杂度要比冒泡排序还要高一些，下来介绍选择排序。 原理每次找到数组中的最大值(从大到小排)或最小值(从小到大排)放在前面。 实现步骤 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。 重复第二步，直到所有元素均排序完毕 特性 时间复杂度： 最好情况：O(n^2) 最坏情况：O(n^2) 平均情况：O(n^2) 空间复杂度：O(1) 稳定性：稳定 动图演示 源码123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;using namespace std;int main()&#123; //待排序的数组 int num[10]=&#123;2,5,8,3,6,9,1,4,7,0&#125;; for(int i=0;i&lt;10;i++) &#123; int temp=i;//标记最小元素 //找到最小元素索引 for(int j=i+1;j&lt;10;j++) &#123; if(num[temp]&gt;num[j]) &#123; temp=j; &#125; &#125; //将最小值放入数组最左边 swap(num[i],num[temp]); &#125; //打印数组 for(int i=0;i&lt;10;i++) &#123; cout &lt;&lt; num[i]&lt;&lt; &quot; &quot;; &#125; return 0;&#125;","tags":[{"name":"排序算法","slug":"排序算法","permalink":"http://example.com/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"}]},{"title":"排序算法之快速排序","date":"2021-06-10T05:38:49.000Z","path":"2021/06/10/排序算法之快速排序/","text":"前面介绍了冒泡排序，其是交换排序的一种，而快速排序是另一种交换排序，下就来介绍快速排序。 原理通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。 实现步骤 设置两个变量 low、high，排序开始时：low=0，high=size-1(size为数组的大小)。 整个数组找基准正确位置，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面，具体步骤如下： 默认数组的第一个数为基准数据，赋值给temp，即temp=num[low]。 因为默认数组的第一个数为基准，所以从后面开始向前搜索（high–-），找到第一个小于key的num[high]，就将 num[high] 赋给 num[low]，即 num[low] = num[high]，然后执行low++,break;。（循环条件是 low!=high） 此时从前面开始向后搜索（low++），找到第一个大于temp的num[low]，就将 num[low] 赋给 num[high]，即 num[high] = num[low]。,然后执行high++,break;（循环条件是 low!=high） 循环 2-3 步骤，直到 low=high，该位置就是基准位置。 把基准数据赋给当前位置。 第一趟找到的基准位置，作为下一趟的分界点。 递归调用（quick_sort）对分界点前和分界点后的子数组排序，重复2.2、2.3、2.4的步骤。 最终就会得到排序好的数组。 特性 时间复杂度 最好情况：每一次将待排数组划分为两个相等的部分（多一少一也算相等），需要logn次划分，此时时间复杂度为 O(nlogn)(其中log以2为底)。 最坏情况：每次划分只能减少一个元素，快排就相当于是冒泡排序了，需要n-1次划分，此时时间复杂度为O(n^2)。 平均时间复杂度为：O(nlogn)(其中log以2为底)。 空间复杂度 O(nlogn)(其中log以2为底)。 稳定性：不稳定。 动态演示 源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;iostream&gt;using namespace std;//声明快排函数void quick_sort(int num[],int low,int high);int main()&#123; //定义一个要排序的数组 int num[10]=&#123;5,4,3,6,9,8,7,1,2,0&#125;; //调用快排的函数 quick_sort(num,0,9); //打印排序之后的结果 for(int i=0;i&lt;10;i++) &#123; cout &lt;&lt; num[i]&lt;&lt; &quot; &quot;; &#125; return 0;&#125;//定义快排函数void quick_sort(int num[],int low,int high)&#123; int temp; //将基准元素存储在temp中 temp = num[low]; //将low和high的值赋值给i,j,因为马上的递归函数需要用到low和high int i=low; int j= high; //进入循环直到i&lt;j时跳出循环,递归结束 while(i&lt;j) &#123; //进入循环直到i=j时跳出循环，代表一个基准值放置在正确的位置 while(i!=j) &#123; //进入循环直到有一个数与基准数相比相对位置不对应跳出循环 while(i!=j) &#123; if(num[j]&lt;temp) &#123; num[i]=num[j]; i++; break; &#125; else &#123; j--; &#125; &#125; //进入循环，前一个循环从后往前找，这个循环从前向后找 while(i!=j) &#123; if(num[i]&gt;temp) &#123; num[j]=num[i]; j--; break; &#125; else &#123; i++; &#125; &#125; &#125; //将基准元素放入指定位置 num[i]=temp; //进入递归，直到所有元素都排列好 quick_sort(num,low,i-1); quick_sort(num,j+1,high); &#125;&#125;","tags":[{"name":"排序算法","slug":"排序算法","permalink":"http://example.com/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"}]},{"title":"排序算法之冒泡排序","date":"2021-06-09T06:28:48.000Z","path":"2021/06/09/排序算法之冒泡排序/","text":"在C++中我们经常会遇到对一组数进行排序，对于排序算法大概可分10种，这里介绍其中最简单的一种——冒泡排序。 原理它走访要排序的元素列，依次比较相邻两个元素的大小，判断是否符合你所想要的规律(从大到小或从小到大)，若符合，则不改变它们的位置，继续寻找下一组，若不符合，则交换两个数的位置，继续判断下一组，直到最大值或最小值出现在数组末尾，在从头开始，将第二大或第二小的数放置末尾，直到数组排序完成。 特性 时间复杂度 最好情况：数组初始状态是正序的，一趟扫描完即可完成排序，所需要比较次数C和需要交换次数M均达到最小值 Cmin=n-1;Mmin=0; 此时的时间复杂度为O(n)。 最坏情况: 文件的初始状态是逆序的，需要n-1趟扫描才能完成排序，每一趟扫描需要n-i次比较，每次比较之后都需要进行交换(需要执行3次操作)，此时的比较次数和需要移动的次数均达到最大值 Cmax=(n-1)n/2~~O(n^2); Mmax= 3(n-1)n/2 ~~O(n^2)。 综上：冒泡排序总的时间复杂度为 O(n^2)。 空间复杂度 最好情况：数组初始状态是正序的，不需要交换元素，就不需要临时变量，空间复杂度为：0。 最坏情况：开始数组顺序为逆序的，每一次比较都会交换元素，空间复杂度为：O(n)。 综上：冒泡排序的平均空间复杂度为O(1)。 稳定性: 因为若相邻两个元素相同，不会交换位置，所以相同的元素的相对位置不会发生改变，所以冒泡排序是稳定的。 相关概念说明 时间复杂度 对序列数据的总操作次数，反映当n变化时，操作次数呈现什么规律。 空间复杂度 是对一个算法在运行过程中临时占用的存储空间大小的度量。 稳定性 稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。 不稳定：如果a原本在b前面，而a=b，排序之后a可能会出现在b的后面。 动态演示 源码1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;using namespace std;int main()&#123; int num[10]=&#123;5,2,6,8,9,7,4,1,3,0&#125;;//待排序的数组 for(int i=0;i&lt;10;i++) &#123; //若提前排好了直接跳出 int num1=0; for(int j=0;j&lt;10-i-1;j++) &#123; if(num[j]&gt;num[j+1]) &#123; swap(num[j],num[j+1]); num1++; &#125; &#125; if(num1==0) &#123; break; &#125; &#125; //打印排好的数组 for(int i=0;i&lt;10;i++) &#123; cout &lt;&lt; num[i]&lt;&lt; &quot; &quot;; &#125; return 0;&#125;","tags":[{"name":"排序算法","slug":"排序算法","permalink":"http://example.com/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"}]},{"title":"BMP格式图像文件的处理","date":"2021-06-08T01:53:33.000Z","path":"2021/06/08/BMP格式图像文件的处理/","text":"与png和jpeg格式不同，BMP格式非常简单，因为它不使用数据压缩，因此BMP文件(二进制文件）很大，现实中不常用到，不过，图像编译器可将任何图像转换为BMP格式。下来介绍用于编辑BMP格式图像文件的程序。 BMP格式BMP格式有不同的版本，我们将介绍最简单和最常用的版本，有时称之为24位真彩色格式。在这种格式中，每个像素表示为三个字节的序列，每个字节分别表示蓝色、绿色和红色值。 BMP格式文件的部分数据项位置 2 ：此文件的大小，以字节为单位。 位置 10：从图像数据起始处的偏移量。 位置18：图片宽度(以像素为单位)。 位置22 ：图片高度(以像素为单位)。 举例： fstream file; //以二进制格式打开文件 file.open(filename,ios::in|ios::out|ios::binary); //get_int函数 int get_int(fstream&amp; stream,int offset){ stream.seekg(offset); int result = 0; int base = 1; for(int i=0;i&lt;4;i++) { result = result +stream.get()*base; base = base*256; } return result;} 若要获取图像的大小 int file_size = get_int(file,2); 图像数据起始处的偏移量 int start_size = get_int(stream,10); 图像宽度 int width = get_int(stream,18); BMP格式图像数据的存储形式图像以一系列像素行的形式存储，从图像最底下一行的像素开始，每个像素行包含一系列蓝色、绿色、红色三元组。行的末尾用额外的字节填充，以便每行中的字节数可被4整除。例如：如果一行仅由三个像素组成，一个青色、一个红色、一个灰色，则改行的编码为： ​ 255 255 0 0 0 255 128 128 128 x y z 其中x y z 是填充字节，是改行长度达到12，为4的倍数。 格式展示： 示例将BMP图像文件替换为负片，即白色变为黑色，青色变为红色，以此类推。 示例代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;string&gt;#include &lt;cstdlib&gt;using namespace std;//函数一: 通过形成负片来处理像素,其中参数blue、green、red为像素的蓝色、绿色、红色通道值void process(int&amp; blue,int&amp; green,int&amp; red)&#123; blue = 255 - blue; green = 255- green; red = 255 - red;&#125;//函数二：从二进制流中获取一个整数（即图像的大小，宽度，高度等），其中参数stream为输入流，offset为带读取整数的偏移地址int get_int(fstream&amp; stream,int offset)&#123; stream.seekg(offset); int result = 0; int base = 1; for(int i=0;i&lt;4;i++) &#123; result = result +stream.get()*base; base = base*256; &#125; return result;&#125;int main()&#123; cout &lt;&lt; &quot;请输入一个格式为BMP的图像文件：&quot;; string filename; cin&gt;&gt; filename; fstream file; //以二进制文件格式打开 file.open(filename,ios::in|ios::out|ios::binary); //获取图像大小 int file_size = get_int(file,2); //获取图像起始处的偏移量 int start = get_int(file,10); //获取图片宽度 int width = get_int(file,18); //获取图片高度 int height = get_int(file,22); //扫描各行，必须占用4个字节的整数倍 int scanline_size = width*3; int padding = 0; if(scanline_size%4!=0) &#123; padding = 4-scanline_size % 4; &#125; if(file_size != start + (scanline_size+padding)*height) &#123; cout &lt;&lt; &quot;图像内部格式不符&quot;&lt;&lt;endl; return 1; &#125; int pos = start; for(int i=0;i&lt;height;i++)//对每个扫描行 &#123; for(int j=0;j&lt;width;j++)//对每个像素 &#123; file.seekg(pos);//去下一个像素 int blue = file.get();//读取像素 int green = file.get(); int red = file.get(); process(blue,green,red);//处理像素 file.seekp(pos);//回到像素起始位置 file.put(blue);//读取像素 file.put(green); file.put(red); pos= pos+3; &#125; file.seekg(padding,ios::cur);//跳过填充字段 pos = pos +padding; &#125; return 0;&#125;","tags":[{"name":"C++_picture","slug":"C-picture","permalink":"http://example.com/tags/C-picture/"},{"name":"C++流","slug":"C-流","permalink":"http://example.com/tags/C-%E6%B5%81/"}]},{"title":"文件的随机访问","date":"2021-06-07T08:51:21.000Z","path":"2021/06/07/文件的随机访问/","text":"前面已经掌握了C++的文件输入输出流，但前面我们的输入方式为顺序访问，下来介绍如何实现文件的随机读写。 顺序访问与随机访问 顺序访问从文件中依次读取一个数据项或者向文件中依次写入一个数据项，没有向前或者向后跳过数据项，这种访问模式称为顺序访问。 随机访问通过文件指针指定访问文件中的特定项，而无须首先读取之前的所有项，这种访问模式称为随机访问。 注：随机访问并没有任何的”随机性”——该术语只是意味着可以读取和修改存储于文件中任何位置的任何项。 文件指针在文件操作中有一个文件指针，用来指明当前应进行读写的位置，没有具体变量。 随机访问有关的成员函数 tellg() : 返回输入文件指针的当前位置。 seekg(文件中的位置) ：将输入文件中指针移到指定的位置。 seekg(位移量，参照位置) : 以参照位置为基础移动若干字节(文件的一个空格相当于一个字节)。 tellp() : 返回输出文件指针的当前位置。 seekp(文件中的位置) ：将输出文件中指针移动到指定的位置。 seekp(位移量，参照位置) : 以参照位置为基础移动若干字节。 注：对于上面的函数均是通过点运算符实现如( file.tellg() )，其中”文件中的位置”和”位移量”为 long 型参数，以字节为单位。”参照位置”可以是下面三者之一： ios::beg 文件开头 ios::cur 指向输入或输出的当前位置 ios::end 文件某尾 比如： file.seekg(3) 指针移动到第三个字节的位置。 file.seekg(-3,ios::cur) 指针从当前位置向前移动三个字节。 file.seekg(3,ios::cur) 指针从当前位置向后移动三个字节。 其他几个成员函数未举例，可根据以上例子自行体会。 目前文件的随机访问的基础知识已介绍完，不过可能会有一种感觉：感觉其很有用，知识也都掌握了，但是其有什么意义呢？怎么知道我想要的数据在文件中的位置，如果有这种感觉，下面的内容可能会对你有帮助。 索引+随机访问 流程 将数据和偏移量(相对于文件开头)一对一建立索引。 将索引文件导入到内存中(数组或向量)。 如果想要查找某条数据，先从索引中找到对应的偏移量然后在从数据文件中取出即可。 优点(相比于顺序访问) 空间优化：索引文件比数据文件小的多。 时间优化：将数据文件内容读入到内存中就需要占用很大的内存。 源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;vector&gt;using namespace std;int main()&#123; ifstream in_file; in_file.open(&quot;input.txt&quot;); string letter1; in_file &gt;&gt; letter1; cout &lt;&lt; letter1&lt;&lt;endl; //我们获取文件当前位置 long num1=in_file.tellg(); //回到文件开头 //法一： in_file.seekg(0,ios::beg); //法二： //in_file.seekg(0); //法三： //in_file.seekg(-num1,ios::cur); //可以逐个测试一下,看看letter1和letter2是否相同： string letter2; in_file &gt;&gt; letter2; cout &lt;&lt; letter2&lt;&lt;endl; ofstream out_file; out_file.open(&quot;output.txt&quot;); string letter3=&quot;hello&quot;; out_file &lt;&lt; letter3&lt;&lt;endl; //我们获取文件的当前位置 long num2=out_file.tellp(); //回到文件开头 //法一: out_file.seekp(0); //法二： //out_file.seekp(0,ios::beg); //法三： //out_file.seekp(-num2,ios::cur); //同样可以逐个测试一下，发现第二次输出letter3完全覆盖了第一次的输出 out_file &lt;&lt; letter3; //以下是利用索引+随机访问 //打开数据文件 ifstream input2; input2.open(&quot;input2.txt&quot;); //打开索引文件 ifstream index; index.open(&quot;index.txt&quot;); vector&lt;long&gt; num3;//存储每一个数据相对于文件开头的起始位置 num3.push_back(0);//给个初始量，使得索引以1开始 long num4; while(index&gt;&gt;num4) &#123; num3.push_back(num4); &#125; //此时我想要得到文件的第二个数据 input2.seekg(num3[2],ios::beg); string letter4; input2 &gt;&gt; letter4; //这里我定义第二个数据为love，你也可以自定义，下输出测试一下 cout &lt;&lt; letter4&lt;&lt;endl; return 0;&#125;","tags":[{"name":"C++流","slug":"C-流","permalink":"http://example.com/tags/C-%E6%B5%81/"}]},{"title":"文件加密之凯撒密码","date":"2021-06-06T07:09:09.000Z","path":"2021/06/06/文件加密之凯撒密码/","text":"在读此篇文章时相信大家已经掌握了C++中的文件输入输出流，下来介绍利用命令行参数实现对文件的加密，本加密使用凯撒密码。 命令行参数 什么是命令行参数根据所使用的系统和C++的开发环境，有不同启动程序的方法。例如：通过在编译器环境中选择“运行”，单击图标，或在shell命令窗口中提示符出键入程序名。对于后一种方法称为“从命令行调用程序”，此种方法可以在程序名后面添加一些其他的参数，这些参数就被叫做命令行参数。 例如，使用如下命令行启动程序： prog -v input.txt 其中程序名就是prog，然后程序会接受两个命令行参数“-v” 和 “input.txt” 。 命令行参数何去何从在使用命令行参数的时候，我们的主函数的定义就与以往有些不同，如下： int main(int argc,char* argv[]) { ​ ······ } 何去：可以看到主函数中多出了两个参数，一个是整数 argc，一个是char类型的字符串常量数组。 而我们的程序名以及所有的命令行参数都储存在argv[]这样一个数组中，其中argc就是数组的大小。 何从：在我们写程序的时候我们就可以调用argv[] 和 argc 来使用命令行参数。 凯撒密码凯撒密码是一种替换加密技术，明文中的所有字母都在字母表上向后（或向前）按照一个固定的数目进行偏移，形成密文，例如，当偏移量是3的时候，所有的字母A将被替换成D，B变成E，以此类推。 下就使用凯撒密码实现对文件的加密和解密。 源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;string&gt;using namespace std;int main(int argc,char* argv[])&#123; //设置密钥，可以随意给定一个整数值，这里我们使用3 int key = 3 ; //设置加密文件流 ifstream input; //设置输出文件流 ofstream output; //判断是加密还是解密，并打开输入文件于输出文件，并判断是否能够成功打开 for(int i=1;i&lt;argc;i++) &#123; string arg = argv[i]; if(i==1) &#123; if(argv[i]==&quot;-d&quot;)//如果命令行参数为-d就是解密 &#123; key= -3; &#125; &#125; else if(i==2) &#123; input.open(arg); if(input.fail()) &#123; cout &lt;&lt; &quot;input文件打开错误:&quot; &lt;&lt; &quot; &quot;&lt;&lt;arg&lt;&lt;endl; return 1; &#125; &#125; else &#123; output.open(arg); if(output.fail()) &#123; cout &lt;&lt; &quot;output文件打开错误：&quot;&lt;&lt; &quot; &quot;&lt;&lt;arg&lt;&lt;endl; return 1; &#125; &#125; &#125; //用户没有输入两个文件，应该退出 if(argc!=4) &#123; cout &lt;&lt; &quot;请输入四个命令行参数，依次为 程序名 -k或-d input.txt output.txt&quot;&lt;&lt;endl; return 1; &#125; //对文件进行加密 char ch; while(input.get(ch)) &#123; output.put(ch+key); &#125; return 0;&#125;","tags":[{"name":"C++流","slug":"C-流","permalink":"http://example.com/tags/C-%E6%B5%81/"},{"name":"文件加密","slug":"文件加密","permalink":"http://example.com/tags/%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86/"}]},{"title":"C++流之读写字符串","date":"2021-06-06T00:05:10.000Z","path":"2021/06/06/C-流之读写字符串/","text":"C++的输入输出是基于流的概念。输入流是数据的源，输出流是数据的目标。下来介绍C++流类的串输入输出流。 字符串流的类型和头文件 字符串流的类型 istringstream：从字符串中读取字符。 ostringstream：将字符写入字符串。 stringstream：即可在字符串中写入字符，也可以读取字符。 字符串流的头文件​ 三种类型的字符串流的使用，头文件均为 &lt;sstream&gt; 打开字符串流 打开字符串输入流12istringstream strm;strm.str(letter); 这里的strm是字符串输入流的一个对象，于标准输入流的cin类似。 其中str是流类的一个成员函数，用于初始化strm，通过点记号来调用。 letter是一个字符串，可以是已存在字符串变量，也可以是自定义字符串(需加双引号)。 打开字符串输出流1ostringstream strm; 这里的strm是字符串输入流的一个对象，于标准输入流的cout类似。 字符串流读入和读出 字符串流读入1234istringstream strm;strm.str(&quot;2021 06 01&quot;);int num;strm&gt;&gt;num; 此时num的数值就是2021。 字符串读出12345ostringstream strm;int year=2021;int month= 6;int day=1;strm &lt;&lt;year&lt;&lt; &quot; &quot; &lt;&lt;month &lt;&lt; &quot; &quot;&lt;&lt;day; 此时字符串strm就是”2021 6 1“。 字符串于数值数据的相互转化 字符串转变为数值 字符串转为int型法一： 1234istringstream strm;strm.str(&quot;2021&quot;);int num;strm &gt;&gt; num; 法二： 123456stringstream strm;string letter = &quot;2021&quot;;int num;strm &lt;&lt; letter;strm&gt;&gt; num;strm.clear();//清空字符串流，再次使用需要重新格式化 法三 12string year = &quot;2021&quot;;int num = stoi(year); 字符串转为double型法一法二完全同上，只需将int改为double。 法三： 12string year = &quot;202.1&quot;;double num = stod(year); 数值转变为字符串 int型转变为字符串法一： 1234ostringstream strm;int num= &quot;2021&quot;;strm &lt;&lt; num;string letter = strm.str(); 法二： 123456stringstream strm;int num=2021;string letter;strm &lt;&lt; num;strm &gt;&gt; letter;strm.clear(); 法三： 12int num=2021;string letter = to_string(num); double 型转变为字符串int型的三种方法均适用。注意：法三字符串变量会保留数值（double型）的小数点后六位，如果不足六位的情况下会使用0补齐，例如：string letter = to_string(2021),此时letter= “2021.000000”。 源码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;sstream&gt;using namespace std;int main()&#123; //打开字符串流 istringstream input; ostringstream output; stringstream in_out_put; //初始化读入字符串流 input.str(&quot;2021 06 01&quot;); //以读入字符串流作为数据源 int num1,num2,num3; input &gt;&gt; num1; input &gt;&gt; num2; input &gt;&gt; num3; cout &lt;&lt; &quot;num1:&quot;&lt;&lt;num1&lt;&lt;endl; cout &lt;&lt; &quot;num2:&quot;&lt;&lt;num2&lt;&lt;endl; cout &lt;&lt; &quot;num3:&quot;&lt;&lt;num3&lt;&lt;endl; //以读出字符串流作为数据结果 output &lt;&lt; num1 &lt;&lt; &quot; &quot; &lt;&lt; num2 &lt;&lt; &quot; &quot; &lt;&lt; num3; string word = output.str(); cout &lt;&lt; &quot;word:&quot; &lt;&lt; word &lt;&lt;endl; //字符串转变为int型 //法一： istringstream input1; input1.str(&quot;2021&quot;); int num4; input1 &gt;&gt; num4; cout &lt;&lt;&quot;num4:&quot;&lt;&lt; num4 &lt;&lt; endl; //法二： stringstream in_out_put1; string letter = &quot;2021&quot;; int num5; in_out_put1 &lt;&lt; letter; in_out_put1 &gt;&gt; num5; in_out_put1.clear(); cout &lt;&lt;&quot;num5:&quot;&lt;&lt; num5 &lt;&lt; endl; //法三： string letter1= &quot;2021&quot;; int num6 = stoi(letter1); cout &lt;&lt; &quot;num6:&quot;&lt;&lt; num6&lt;&lt;endl; //字符串转变为double型 //法一： istringstream input2; input2.str(&quot;202.1&quot;); double num7; input2 &gt;&gt; num7; cout &lt;&lt;&quot;num7:&quot;&lt;&lt; num7 &lt;&lt; endl; //法二： stringstream in_out_put2; string letter2 = &quot;202.1&quot;; double num8; in_out_put2 &lt;&lt; letter2; in_out_put2 &gt;&gt; num8; in_out_put2.clear(); cout &lt;&lt;&quot;num8:&quot;&lt;&lt; num8 &lt;&lt; endl; //法三： string letter3= &quot;202.1&quot;; double num9 = stod(letter3); cout &lt;&lt; &quot;num9:&quot;&lt;&lt; num9&lt;&lt;endl; //int型转变为字符串 //法一： ostringstream output1; int num10 = 2021; output1 &lt;&lt; num10; string word1 = output1.str(); cout &lt;&lt; &quot;word1:&quot;&lt;&lt; word1&lt;&lt;endl; //法二： stringstream in_out_put3; int num11 = 2021; string word2; in_out_put3 &lt;&lt; num11; in_out_put3 &gt;&gt;word2; in_out_put3.clear(); cout &lt;&lt; &quot;word2:&quot;&lt;&lt; word2&lt;&lt;endl; //法三： int num12 = 2021; string word3=to_string(num12); cout &lt;&lt; &quot;word3:&quot;&lt;&lt;word3&lt;&lt;endl; //double型转变为字符串 //法一： ostringstream output2; double num13 = 202.1; output2 &lt;&lt; num13; string word4 = output2.str(); cout &lt;&lt; &quot;word4:&quot;&lt;&lt; word4&lt;&lt;endl; //法二： stringstream in_out_put4; double num14 = 202.1; string word5; in_out_put4 &lt;&lt; num14; in_out_put4 &gt;&gt;word5; in_out_put4.clear(); cout &lt;&lt; &quot;word5:&quot;&lt;&lt; word5&lt;&lt;endl; //法三： double num15 = 202.1; string word6=to_string(num15); cout &lt;&lt; &quot;word6:&quot;&lt;&lt;word6&lt;&lt;endl; return 0;&#125;","tags":[{"name":"C++流","slug":"C-流","permalink":"http://example.com/tags/C-%E6%B5%81/"}]},{"title":"C++流之读写文本文件","date":"2021-06-05T01:45:54.000Z","path":"2021/06/05/C-流之读写文本文件/","text":"​ C++输入输出是基于流的概念。输入流是数据的源，输出流是数据的目标，下来介绍文件输入输出流。 文件流的类型和头文件 文件流有三种类型： 用于输入：ifstream 用于输出：ofstream 即可用于输入也可用于输出：fstream 当使用三种文件流的任何一个时，头文件均为 &lt;fstream&gt; 打开和关闭文件流，并判断是否打开成功 打开文件流 打开输入文件流： 12ifstream in_file;in_file.open(&quot;input.txt&quot;); 这里的 in_file 是文件输入流的一个对象，对于标准输入流 cin 的用法在其上完全适用。 其中open是其一个成员函数，使用点记号来进行调用。 input.txt 是储存在源文件下名为”input“的一个文本文档，里面的内容用于以后的输入。 打开输出文件流： 12ofstream out_file;out_file.open(&quot;output.txt&quot;); 这里的 out_file 是文件输出流的一个对象，对于标准输出流 cout 的用法在其上完全适用。 其中open是其一个成员函数，使用点记号来进行调用。 output.txt 是一个输出文件，使用上述语句时会在源文件中生成一个名为”output“的文本文档，输出的内容皆在这里显示。 判断是否成功打开输入文件流12345678910ifstream in_file;in_file.open(&quot;input.txt&quot;);if(in_file.fail())&#123;​ cout&lt;&lt; &quot;Can&#x27;t open input.txt&quot;&lt;&lt;endl;&#125;else&#123;​ 读取输入&#125; 注：这里的in_file.fail() 中的fail 是一个成员函数，如果打开文件失败，会返回一个true值。 关闭文件流123ifstream in_file;in_file.open(&quot;input.txt&quot;);in_file.close(); 注: 这里的in_file.close() 中的close是一个成员函数，一般在程序结束是所有之前打开的流都会自动关闭，只有在流变量(这里是in_file)处理另一个文件是，才需要手动关闭。 文件流读入和读出，并判断是否成功读入 文件流读入1234ifstream in_file;in_file.open(&quot;input.txt&quot;);string letter;in_file &gt;&gt; letter; 注：可以看到文件流的读入 in_file &gt;&gt; letter; 于标准读入cin&gt;&gt; letter; 用法相同；不同的是in_file &gt;&gt;letter;是从文本文档 input 中读入，而cin&gt;&gt;letter,是从键盘键入。 文件流读出1234ofstream out_file;out_file.open(&quot;output.txt&quot;);string letter2=&quot;hello world&quot;;out_file &lt;&lt; letter2; 注：可以看到文件流的读出 out_file &lt;&lt; letter2; 于标准读出cout &lt;&lt; letter2; 用法相同；不同的是out_file &lt;&lt; letter2;是将“hello world” 写入文本文档output中，而cout &lt;&lt; letter2,是将“hello world”写入显示屏。 判断是否读入成功123456789101112ifstream in_file;in_file.open(&quot;input.txt&quot;);string letter;in_file &gt;&gt; letter;if(in_file.fail())&#123;​ cout &lt;&lt; &quot;输入错误&quot;；&#125;else&#123;​ 处理输入；&#125; 注：可以看到其用法于cin.fail()用法相同，当输入错误(当试图从文本中读取数字例如：55，但读入的数据项并不是标准的格式化数字例如：55a，则读取失败，in_file.fail()会返回一个true值。 值得说明的是，当从文件读取输入时，数字格式错误并不是失败的唯一原因，假设已经使用了文件中包含的所有数据，并试图读取更多的数据项时，文件流就会进入失败状态，而对于格式输入流cin就会一直等待用户输入。因此当一个输入流文件中的数据类型均为数值，我们想要计算其均值，即可直接使用如下语句： 1234567891011ifstream in_file；in_file.open(input.txt);double tatol=0;double num1=0;double num;while(in_file&gt;&gt;num)&#123; tatol+=num; num1++;&#125;int average = tatol/num1; 举例读取文本文档input.txt中的所有行，并将其按行逆序输出到文本文档output.txt中。 示例代码123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;vector&gt;using namespace std;int main()&#123; ifstream in_file; in_file.open(&quot;input.txt&quot;);//打开输入流文件 if(in_file.fail())//判断是否成功打开文件 &#123; cout &lt;&lt; &quot;文件打开有误&quot;; &#125; else &#123; ofstream out_file; out_file.open(&quot;output.txt&quot;);//打开输出流文件 vector&lt;string&gt; letter; string word; while(getline(in_file,word))//文件流读入，getline为按行读入，当读取完全部数据返回false &#123; if(in_file.fail())//判断是否读入成功 &#123; cout &lt;&lt; &quot;数据类型不符，读入错误&quot;; &#125; else &#123; letter.push_back(word);//按行存储文件中的内容 &#125; &#125; for(int i=letter.size()-1;i&gt;=0;i--) &#123; out_file &lt;&lt; letter[i]&lt;&lt;endl;//文件流读出 &#125; in_file.close();//关闭输入流文件 out_file.close();//关闭输出流文件 &#125;&#125; ​","tags":[{"name":"C++流","slug":"C-流","permalink":"http://example.com/tags/C-%E6%B5%81/"}]},{"title":"从宏观上看C++流","date":"2021-06-04T10:12:49.000Z","path":"2021/06/04/C-流/","text":"C++流主要是通过输入流和输出流来读写文件，其对于处理真实世界的数据是一个非常实用的技巧,以下来对其进行详细的介绍。 什么是C++流C++的流是一种数据的载体，通过它可以实现数据交换和传输。就像水流是由一串水组成的一样，C++的数据流就是由一串数据组成的更长数据。简单来说，C++流就是输入和输出，其中输入流就是数据从键盘、文件或者是指定字符串流入到程序中；输出流就是程序中的数据流向屏幕、文件或字符串。 C++中的输入流和输出流 通过标准输入设备——键盘（C++中使用cin），或标准输出设备——显示器（C++中使用cout）进行输入和输出操作，简称为标准I/O。 通过对文件进行输入和输出操作，简称为文件I/O。 通过对程序中的指定字符串进行输入和输出操作，简称为串I/O。 C++中输入输出流使用的头文件 标准输入输出：#include &lt;iostream&gt; 文件输入输出： #include &lt;fstream&gt; 串输入输出： #include &lt;sstream&gt; 为什么要使用C++流 毫无疑问，一个有意义的程序一定会有程序本身想要的输入，和你所想看到的输出，这是一个程序最本质的意义。 对于标准输入输出流：在所需要输入的数据比较简单，数量少，输出的数据也比较简单，并且是一个即时的数据，使用标准输入输出流是有很大裨益的。 对于文件输入输出流： 在所需要的数据很庞大，并且在文件中有着一定的规律（例如表格），使用文件输入流很有必要。 在需要对程序进行大量的测试，需要对同样或者大部分相同的数据进行输入，使用文件流可节省很多时间。 通过文件输入输出流可以对文件进行加密以保护文件的安全。 对于串输入输出流： 以字符串作为输入可以实现从字符串到数值型数据的转变。 当需要从一个长字符串中提取一些想要的信息，使用串输入输出流是比较方便的（例：从 “2021 年 6 月 1 日“中提取月份，即可将此长字符串作为一个输入流，依次读入到第三个数据即为月份）。 C++流我们应该学到什么 对于文件输入输出流的使用即读写文本文件。 对于串输入输出流的使用即读写字符串。 文件加密。 文件输入输出流的随机访问。 处理BMP格式的图像文件。 友情提示：若要详细学习C++流的5点内容，请点击标签中的C++流。","tags":[{"name":"C++流","slug":"C-流","permalink":"http://example.com/tags/C-%E6%B5%81/"}]},{"title":"C++操作图像中的像素-Picture类","date":"2021-06-04T09:45:23.670Z","path":"2021/06/04/C-操作图像中的像素/","text":"​ 数字图像由像素组成，在C++中操作图像即是对图像中的某些或全部像素的操作，下介绍使用picture类型对图片像素进行操作。 如何使用picture类型 将文件picture.cpp、picture.h、lodepng.cpp和lodepng.h复制到用户的源文件所在文件夹（注：文件可在wiley.com./go/bclo3中的配套代码下的ch04/worked_example_2下找到），如下图： 在工作空间中打开它们，具体步骤：右键picture-&gt;添加文件-&gt;同时打开4个文件，然后编译器会弹出信息，点击确定即可，打开之后如下图： 在头文件中使用如下语句：#include “picture.h”,注：picture.h应由引号而不是尖括号括起来。 将要处理的图片复制到源文件所在的文件夹，图片名称为queen注：图片的类型必需为png类型。 打开图片，使用如下代码：Picture pic(“queen.png”)。 ​ 该语句定义了一个Picture 类型的变量 pic，用于保存图片的像素。 ​ 图片中每一个像素都有x和y坐标，其中0&lt;=x&lt;pic.width()(即图片的宽度)，0&lt;=y&lt;pic.height()(即图片的高度);例如(0,0)就位于图片的左上角，且y轴向下。 ​ 对于每一个像素都有一个RGB颜色值，该值由三原色组成：红、绿、蓝。每一个原色值都在0~255之间，所以我们操作图片中的像素即通过改变像素的颜色值来达到我们的目的。 Picture类型部分成员函数 pic.width() 和 pic.height() ； 分别用来访问图片的的宽度和高度。 pic.red(x,y)、pic.blue(x,y) 和 pic.green(x,y) ； 分别用来获取像素(x,y)处红色原色值、蓝色原色值以及绿色原色值。 pic.set(x,y,red,green,bule)； 将像素(x,y)处设定为自定义原色值，其中后3个参数均为0~255之间的数值。 Picture pic2(“queen2.png”); pic.add(pic2,num1,num2); 这是在图片pic中添加图片pic2，其中num1，num2 分别为pic2相对于(0,0)这个位置的位移。 pic.save(“result.png”)； 将操作后的图片保存。注：会在源文件中生成一个名为result，类型为png的图片。 Picture pic3(num1,num2,num3,num4,num5); 不从源文件中加载图片，生成一张单色的图片，其中num1,num2 分别指定图片的宽度的高度，num3、num4、num5 分别代表着图片每一个像素的红、绿、蓝原色值。 举例：编写程序，将图片queen中的每一个像素的个原色值都变成其相反值。 示例代码：123456789101112131415161718192021#include &lt;iostream&gt;#include &quot;picture.h&quot;using namespace std;int main()&#123; Picture pic(&quot;queen.png&quot;); for(int i=0;i&lt;pic.height();i++) &#123; for(int j=0;j&lt;pic.width();j++) &#123; int red=pic.red(j,i); int green = pic.green(j,i); int bule=pic.blue(j,i); pic.set(j,i,255-red,255-green,255-bule); &#125; &#125; pic.save(&quot;upset_down.png&quot;); return 0;&#125;","tags":[{"name":"C++_picture","slug":"C-picture","permalink":"http://example.com/tags/C-picture/"}]}]